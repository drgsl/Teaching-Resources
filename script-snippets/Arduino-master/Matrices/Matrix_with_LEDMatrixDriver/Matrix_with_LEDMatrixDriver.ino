#include <LEDMatrixDriver.hpp>

// This draw a moving sprite on your LED matrix using the hardware SPI driver Library by Bartosz Bielawski.
// Example written 16.06.2017 by Marko Oette, www.oette.info

// Define the ChipSelect pin for the led matrix (Dont use the SS or MISO pin of your Arduino!)
// Other pins are Arduino specific SPI pins (MOSI=DIN, SCK=CLK of the LEDMatrix) see https://www.arduino.cc/en/Reference/SPI
const uint8_t LEDMATRIX_CS_PIN = 9;

// Number of 8x8 segments you are connecting
const int LEDMATRIX_SEGMENTS = 4;
const int LEDMATRIX_WIDTH    = LEDMATRIX_SEGMENTS * 8;

// The LEDMatrixDriver class instance
LEDMatrixDriver lmd(LEDMATRIX_SEGMENTS, LEDMATRIX_CS_PIN);
LEDMatrixDriver lmd2(LEDMATRIX_SEGMENTS / 2, LEDMATRIX_CS_PIN);

byte StickmanFrames[6][8] = {{B00011000, B00100100, B00100100, B00011000, B01111110, B00011000, B00100100, B01000010},
  {B00011000, B00100100, B00100100, B00011010, B01111100, B00011000, B01100100, B00000010},
  {B00011000, B00100100, B00100100, B00011010, B00111100, B01011000, B00110100, B00000100},
  {B00011000, B00100100, B00100100, B00011010, B00111100, B01011000, B00011000, B00011000},
  {B00011000, B00100100, B00100100, B00011010, B00111100, B01011000, B00010100, B00010000},
  {B00011000, B00100100, B00100100, B00011000, B00111110, B01011000, B00010100, B00010100}
};
const uint8_t windmill[] =
{
0x91, 0x4a, 0x34, 0x5d, 0xba, 0x2c, 0x52, 0x89
};

byte font[95][8] = { {0, 0, 0, 0, 0, 0, 0, 0}, // SPACE
  {0x10, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18}, // EXCL
  {0x28, 0x28, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00}, // QUOT
  {0x00, 0x0a, 0x7f, 0x14, 0x28, 0xfe, 0x50, 0x00}, // #
  {0x10, 0x38, 0x54, 0x70, 0x1c, 0x54, 0x38, 0x10}, // $
  {0x00, 0x60, 0x66, 0x08, 0x10, 0x66, 0x06, 0x00}, // %
  {0, 0, 0, 0, 0, 0, 0, 0}, // &
  {0x00, 0x10, 0x18, 0x18, 0x08, 0x00, 0x00, 0x00}, // '
  {0x02, 0x04, 0x08, 0x08, 0x08, 0x08, 0x08, 0x04}, // (
  {0x40, 0x20, 0x10, 0x10, 0x10, 0x10, 0x10, 0x20}, // )
  {0x00, 0x10, 0x54, 0x38, 0x10, 0x38, 0x54, 0x10}, // *
  {0x00, 0x08, 0x08, 0x08, 0x7f, 0x08, 0x08, 0x08}, // +
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x08}, // COMMA
  {0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00}, // -
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x06}, // DOT
  {0x00, 0x04, 0x04, 0x08, 0x10, 0x20, 0x40, 0x40}, // /
  {0x00, 0x38, 0x44, 0x4c, 0x54, 0x64, 0x44, 0x38}, // 0
  {0x04, 0x0c, 0x14, 0x24, 0x04, 0x04, 0x04, 0x04}, // 1
  {0x00, 0x30, 0x48, 0x04, 0x04, 0x38, 0x40, 0x7c}, // 2
  {0x00, 0x38, 0x04, 0x04, 0x18, 0x04, 0x44, 0x38}, // 3
  {0x00, 0x04, 0x0c, 0x14, 0x24, 0x7e, 0x04, 0x04}, // 4
  {0x00, 0x7c, 0x40, 0x40, 0x78, 0x04, 0x04, 0x38}, // 5
  {0x00, 0x38, 0x40, 0x40, 0x78, 0x44, 0x44, 0x38}, // 6
  {0x00, 0x7c, 0x04, 0x04, 0x08, 0x08, 0x10, 0x10}, // 7
  {0x00, 0x3c, 0x44, 0x44, 0x38, 0x44, 0x44, 0x78}, // 8
  {0x00, 0x38, 0x44, 0x44, 0x3c, 0x04, 0x04, 0x78}, // 9
  {0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00}, // :
  {0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x08}, // ;
  {0x00, 0x10, 0x20, 0x40, 0x80, 0x40, 0x20, 0x10}, // <
  {0x00, 0x00, 0x7e, 0x00, 0x00, 0xfc, 0x00, 0x00}, // =
  {0x00, 0x08, 0x04, 0x02, 0x01, 0x02, 0x04, 0x08}, // >
  {0x00, 0x38, 0x44, 0x04, 0x08, 0x10, 0x00, 0x10}, // ?
  {0x00, 0x30, 0x48, 0xba, 0xba, 0x84, 0x78, 0x00}, // @
  {0x00, 0x1c, 0x22, 0x42, 0x42, 0x7e, 0x42, 0x42}, // A
  {0x00, 0x78, 0x44, 0x44, 0x78, 0x44, 0x44, 0x7c}, // B
  {0x00, 0x3c, 0x44, 0x40, 0x40, 0x40, 0x44, 0x7c}, // C
  {0x00, 0x7c, 0x42, 0x42, 0x42, 0x42, 0x44, 0x78}, // D
  {0x00, 0x78, 0x40, 0x40, 0x70, 0x40, 0x40, 0x7c}, // E
  {0x00, 0x7c, 0x40, 0x40, 0x78, 0x40, 0x40, 0x40}, // F
  {0x00, 0x3c, 0x40, 0x40, 0x5c, 0x44, 0x44, 0x78}, // G
  {0x00, 0x42, 0x42, 0x42, 0x7e, 0x42, 0x42, 0x42}, // H
  {0x00, 0x7c, 0x10, 0x10, 0x10, 0x10, 0x10, 0x7e}, // I
  {0x00, 0x7e, 0x02, 0x02, 0x02, 0x02, 0x04, 0x38}, // J
  {0x00, 0x44, 0x48, 0x50, 0x60, 0x50, 0x48, 0x44}, // K
  {0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7c}, // L
  {0x00, 0x82, 0xc6, 0xaa, 0x92, 0x82, 0x82, 0x82}, // M
  {0x00, 0x42, 0x42, 0x62, 0x52, 0x4a, 0x46, 0x42}, // N
  {0x00, 0x3c, 0x42, 0x42, 0x42, 0x42, 0x44, 0x38}, // O
  {0x00, 0x78, 0x44, 0x44, 0x48, 0x70, 0x40, 0x40}, // P
  {0x00, 0x3c, 0x42, 0x42, 0x52, 0x4a, 0x44, 0x3a}, // Q
  {0x00, 0x78, 0x44, 0x44, 0x78, 0x50, 0x48, 0x44}, // R
  {0x00, 0x38, 0x40, 0x40, 0x38, 0x04, 0x04, 0x78}, // S
  {0x00, 0x7e, 0x90, 0x10, 0x10, 0x10, 0x10, 0x10}, // T
  {0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3e}, // U
  {0x00, 0x42, 0x42, 0x42, 0x42, 0x44, 0x28, 0x10}, // V
  {0x80, 0x82, 0x82, 0x92, 0x92, 0x92, 0x94, 0x78}, // W
  {0x00, 0x42, 0x42, 0x24, 0x18, 0x24, 0x42, 0x42}, // X
  {0x00, 0x44, 0x44, 0x28, 0x10, 0x10, 0x10, 0x10}, // Y
  {0x00, 0x7c, 0x04, 0x08, 0x7c, 0x20, 0x40, 0xfe}, // Z
  // (the font does not contain any lower case letters. you can add your own.)
};    // {}, //
byte InvaderFrames[2][8] = { {0x18, 0x3c, 0x7e, 0xdb, 0xff, 0x24, 0x5a, 0xa5},
  {0x18, 0x3c, 0x7e, 0xdb, 0xff, 0x24, 0x5a, 0x42},
};
byte PacmanFrames[2][8] = { {0x3c, 0x7e, 0xdf, 0xff, 0xf0, 0xff, 0x7e, 0x3c},
  {0x3c, 0x7e, 0xdc, 0xf8, 0xf8, 0xfc, 0x7e, 0x3c},
};
byte BunnyFrames[2][8] = { {0x66, 0x66, 0x66, 0xff, 0x81, 0xa5, 0x99, 0x7e},
  {0x66, 0xe7, 0x66, 0xff, 0x81, 0xa5, 0x99, 0x7e}
};
byte DandoFrames[2][8] = { {0x00, 0xff, 0x81, 0xa5, 0x81, 0x81, 0xff, 0x00},};
byte GhostFrames[5][8] = { {0x18, 0x7e, 0xff, 0xbd, 0xff, 0xff, 0xff, 0xa5},
  {0x18, 0x7e, 0xbd, 0xff, 0xff, 0xff, 0xff, 0xa5},
  {0x18, 0x7e, 0xdb, 0xff, 0xff, 0xff, 0xff, 0xa5},
  {0x18, 0x7e, 0xff, 0xdb, 0xff, 0xff, 0xff, 0xa5},
  {0x18, 0x7e, 0x99, 0x99, 0xff, 0xff, 0xff, 0xa5}
};
byte Ghost2Frames[1][8] = {0x3c, 0x7e, 0xd7, 0xff, 0xc3, 0xff, 0xff, 0xdb};

int AnimIndex = 0;
const int AnimDelay = 100;
char text[] = "** LED MATRIX DEMO! ** (1234567890) ++ \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ++ <$%/=?'.@,> --";
int x = 0, y = 0; // start top left

void setup() {
  // init the display
  lmd.setEnabled(true);
  lmd.setIntensity(0);   // 0 = low, 10 = high


  lmd2.setEnabled(true);
  lmd2.setIntensity(2);   // 0 = low, 10 = high
}
void loop() {
  for (int x = -7; x <= LEDMATRIX_WIDTH; x++) {
    lmd.clear();
    drawSprite( (byte*)&StickmanFrames[AnimIndex], x, 0, 8, 8 );
    AnimIndex = (AnimIndex + 1) % (sizeof(StickmanFrames) / sizeof(StickmanFrames[0]));
    lmd.display();
    delay(AnimDelay);
  }

  for (int x = -7; x <= LEDMATRIX_WIDTH + 36; x++) {
    lmd.clear();
    AnimIndex = (AnimIndex + 1) % (sizeof(GhostFrames) / sizeof(GhostFrames[0]));
    drawSprite( (byte*)&InvaderFrames[AnimIndex % 2], x, 0, 8, 8 );
    drawSprite( (byte*)&PacmanFrames[AnimIndex % 2], x - 9, 0, 8, 8 );
    drawSprite( (byte*)&BunnyFrames[AnimIndex % 2], x - 18, 0, 8, 8 );
    drawSprite( (byte*)&DandoFrames[AnimIndex % 2], x - 27, 0, 8, 8 );
    drawSprite( (byte*)&GhostFrames[AnimIndex], x - 36, 0, 8, 8 );
    lmd.display();
    delay(AnimDelay);
  }

  //  int len = strlen(text);
  //  DrawTextUp(text, len, x, 0);
  //  delay(AnimDelay);
  //  if ( --x < len * -8 ) {
  //    x = LEDMATRIX_WIDTH;
  //  }

  
  //drawSprite( (byte*)&windmill[0], 0, 0, 8, 8 );

}



void DrawTextDown(char* text, int len, int x, int y ) {
  for ( int idx = 0; idx < len; idx ++ )
  {
    int c = text[idx] - 32;

    // stop if char is outside visible area
    if ( x + idx * 8  > LEDMATRIX_WIDTH)
      return;

    // only draw if char is visible
    if ( 8 + x + idx * 8 > LEDMATRIX_WIDTH / 2 + 7)
      drawSprite( font[c], x + idx * 8, y, 8, 8 );
  }
}
void DrawTextUp(char* text, int len, int x, int y ) {
  for ( int idx = 0; idx < len; idx ++ )
  {
    int c = text[idx] - 32;

    // stop if char is outside visible area
    if ( x + idx * 8  > LEDMATRIX_WIDTH / 2 - 7)
      return;

    // only draw if char is visible
    if ( 8 + x + idx * 8 > 0)
      drawSprite( font[c], x + idx * 8, y, 8, 8 );
  }
}
void DrawTextBoth(char* text, int len, int x, int y ) {
  for ( int idx = 0; idx < len; idx ++ )
  {
    int c = text[idx] - 32;

    // stop if char is outside visible area
    if ( x + idx * 8  > LEDMATRIX_WIDTH / 2)
      return;

    // only draw if char is visible
    if ( 8 + x + idx * 8 > 0)
      drawSprite2( font[c], x + idx * 8, y, 8, 8 );
  }
}


void drawSprite( byte* sprite, int x, int y, int width, int height ) {
  // The mask is used to get the column bit from the sprite row
  byte mask = B10000000;

  for ( int iy = 0; iy < height; iy++ )
  {
    for ( int ix = 0; ix < width; ix++ )
    {
      lmd.setPixel(x + ix, y + iy, (bool)(sprite[iy] & mask ));

      // shift the mask by one pixel to the right
      mask = mask >> 1;
    }

    // reset column mask
    mask = B10000000;
  }
  lmd.display();
}
void drawSprite2( byte* sprite, int x, int y, int width, int height ) {
  // The mask is used to get the column bit from the sprite row
  byte mask = B10000000;

  for ( int iy = 0; iy < height; iy++ )
  {
    for ( int ix = 0; ix < width; ix++ )
    {
      lmd2.setPixel(x + ix, y + iy, (bool)(sprite[iy] & mask ));

      // shift the mask by one pixel to the right
      mask = mask >> 1;
    }

    // reset column mask
    mask = B10000000;
  }
  lmd2.display();

}
void drawString(char* text, int len, int x, int y ) {
  for ( int idx = 0; idx < len; idx ++ )
  {
    int c = text[idx] - 32;

    // stop if char is outside visible area
    if ( x + idx * 8  > LEDMATRIX_WIDTH )
      return;

    // only draw if char is visible
    if ( 8 + x + idx * 8 > 0 )
      drawSprite( font[c], x + idx * 8, y, 8, 8 );
  }
}
